[
  {
    "objectID": "core_shiny.html",
    "href": "core_shiny.html",
    "title": "Shiny Architecture",
    "section": "",
    "text": "Every R Shiny app–no matter how nuanced and visually appealing–is composed of three components:\n\nUser Interface (“UI”)\nServer\nshinyApp R function that binds the UI and server together\n\nLet’s delve into each of these in greater detail to better understand how they collectively make up a Shiny app.\nBefore we can do that however, we need one key R package installed, namely: shiny. shiny is, perhaps unsurprisingly, the core workhorse package of most Shiny apps. One huge benefit of Shiny is that you can use any R package inside of a Shiny app, which makes things like manipulating data or plotting more familiar. However, the only required package to create a Shiny app is shiny.\n\n# install.packages(\"librarian\")\nlibrarian::shelf(shiny)\n\nWith that package installed, we can continue."
  },
  {
    "objectID": "core_shiny.html#user-interface",
    "href": "core_shiny.html#user-interface",
    "title": "Shiny Architecture",
    "section": "User Interface",
    "text": "User Interface\nThe User Interface (“UI”) is everything that you see in a functioning R Shiny app. In fact, you can create an entire, functioning shiny app only in the UI, with formatted text, images, links, et cetera. If you only code in the UI, you end up making a static web page, much like a wsywyg editor like wordpress or drupal might generate.\nThe power of shiny comes when you let users interact with the data, and the app responds to their selections. This requires making reactive objects in the server, the key to unlocking the full power of shiny. We’ll dive into this connection later. For now, we focus on the UI.\nLet’s take a very basic example:\n\n# Define UI\nbasic_ui <- fluidPage(\n  \"Here's some text\"\n)\n\nHere, we just tell the UI that we want some text to display. fluidPage is a function in the shiny package that defines the page structure—there’s a few others, but fluidPage is a great default, because it’s incredibly flexible. It wraps the code for the entire app! We’ll worry about more complicated structure later.\nWe can add other elements, too:\n\nbasic_ui <- fluidPage(\n  titlePanel(\"A simple app\"),\n  \"Here's some text\",\n  img(src = \"https://lternet.edu/wp-content/themes/ndic/library/images/logo.svg\")\n)\n\nThe shiny package contains some convenient functions for formatting and placement. In this case, we used titlePanel to format some text as a title, and the img function to render an image from a source on the internet. If you want something to display, there’s likely a shiny function that let’s you do it easily.\nIf we want to run the app, we need to define both the server, and then run the shinyApp function that tells R to stitch it all together. In this case, our server is empty, because we don’t actually need the app to do anything behind the hood yet. Note that the server is just a user defined function with the variables input and output — not a pre defined function.\nAt the end, we use the shinyApp function to tell R to compile our server and ui into an app.\n\n# Define server\nbasic_server <- function(input, output){ }\n\n# Create the app\nshinyApp(ui = basic_ui, server = basic_server)\n\n\n\n\nIf you know a bit of web development, the app you create might look like what you get when you code HTML without any CSS styling. A huge benefit of shiny is that we can actually define the layout and styling within the UI, alongside the actual objects (text, images)—though we did minimal formatting in this case. More on this later—and if these last two sentences make no sense, it’s totally fine to ignore them and move on!"
  },
  {
    "objectID": "core_shiny.html#creating-a-reactive-ui",
    "href": "core_shiny.html#creating-a-reactive-ui",
    "title": "Shiny Architecture",
    "section": "Creating a Reactive UI",
    "text": "Creating a Reactive UI\nSo far, we haven’t made Shiny do anything very useful—and it’s certainly more convoluted than a “wsywyg” editor (“What You See is What You Get”). But say we had a goal of creating an interactive app? Maybe radio buttons where a user can select an option, then see a different output based on that selection?\nIf the UI defines what a user sees, we want them to see two things: the radio buttons, but also the output—maybe some text in this case—that the buttons generate.\nThis concept is key: the UI includes both the things that users can interact with (check boxes, text fields, etc.) and the things that user’s inputs create or modify (plots, printed messages, etc.).\nLet’s start coding this up, starting with adding the buttons:\n\n# Define the UI\nreactive_ui <- fluidPage(\n  \n    # Let's create the input\n  numericInput(inputId = \"my_input\",\n               label = \"Type a number\",\n               value = 25)\n  \n)\n\nNotice that this also uses a convenient function in the shiny package: numericInput. There are many functions that let you add interactive objects, which shiny users generally call widgets. We can internally name the buttons using the inputId argument, which lets us refer to it (and also the output it generates!) in later code.\nLet’s also define where we want the results of our selection to show up. The syntax mirrors defining an input:\n\n# Define the UI\nreactive_ui <- fluidPage(\n  \n    # Let's create the radio buttons\n  numericInput(inputId = \"my_input\",\n               label = \"Type a number\",\n               value = 25),\n  \n    # And print the output\n  \"Square root is: \",\n  textOutput(outputId = \"my_output\")\n  \n  )  \n\nWe similarly want to define the output ID so we can refer to it later. The inputId and outputId arguments let us connect a specific input to a specific output in the server, which we’ll do in a moment.\nThree quick notes on the UI code:\n\nThe type of UI element is defined by which *Input function you use. In the above example, we used numericInput so our app will give us a field that accepts numbers. If you wanted a checkbox instead, you’d need to use checkboxInput\n\nIf you downloaded all of the contents of this workshop’s GitHub repository, check out the “ui_elements.R” script for an example of some of the more common UI inputs\n\nNotice how after each bit of the UI (the input, some text, and the output) there is a comma (,) but they are otherwise all just loose inside of the fluidPage parentheses\n\nThis syntax is key to the flexibility of Shiny apps because you can add any number of things and they’ll show up in the app (we’ll cover defining app layouts later)\n\nNot a syntax note per se but be careful with matching your parentheses!\n\nShiny apps (particularly the UI) can be many lines and it is easy to forget to close all the parentheses. We recommend turning on “Rainbow parentheses” in RStudio’s preferences to help make this easier\nRStudio -> Preferences -> Code -> Display -> Rainbow parentheses (check the checkbox)"
  },
  {
    "objectID": "core_shiny.html#server",
    "href": "core_shiny.html#server",
    "title": "Shiny Architecture",
    "section": "Server",
    "text": "Server\nOur new app is interactive, so we now actually have to put something in the server function!\nThe server is the “behind the curtain” part of a Shiny app. The server receives all inputs from the User Interface, then uses the code that you write in the server to create the outputs based on the inputs. These outputs are then returned to the UI so that the user can see the result of their selection.\nIn terms of code, the server is actually one big function that accepts UI inputs and performs whatever operation(s) you specify. If you don’t usually write your own functions, don’t worry! See the example below to help clarify these ideas:\n\nServer Example\nReturning to our growing app, let’s tell the server how to handle our inputs.\n\n# Define the server\nreactive_server <- function(input, output){\n  \n  # Let's take the numeric input and take the square root\n  output$my_output <- renderText( sqrt(input$my_input) )\n  \n}\n\nThe syntax is a bit unique compared to other R code, so let’s break it down.\nWe first need to define where we want the output to display. Remember those names we gave the inputs and outputs in the UI? Here’s where they come in handy.\nWe know we want to create our output called my_output. Every output in the server starts with output$, and the ID of the output widget follows the dollar sign. Think of this like a named object in R, which we can assign to something. So, we start with output$my_output, followed by the assignment operator <-.\nMost often, you want to assign the output object to a bit of code that generates something. Shiny has it’s own set of functions that prepare objects for display in the UI, which all start with render* and usually finish with a descriptive term of the output. In this case, we’re just asking the app to render some text that tells us if the checkbox is checked, so we use… renderText! And in those parentheses, we know we want the output generated by our numeric input, so we refer to it using its name: input$my_input.\nNotes on server code:\n\nPutting function(input, output) tells the server that it should expect things called input and things called output\n\nMissing either of these will mean your app doesn’t know what to look for, and it won’t work\n\nNotice how the input$... and output$... names are exact matches for what we put as the inputId and outputId in the UI\n\nThis is no accident! In the UI, in/outputs are given IDs, in the server they are placed into intermediary in/output objects\n\n\n\n\nRun this final app!\nDouble check that your Environment includes both the reactive_ui and reactive_server objects. If you are missing one or both, re-run the corresponding code chunk above. Once you have both objects, run the following code.\n\nshinyApp(ui = reactive_ui, server = reactive_server)\n\n\n\n\nOnce you run this line, you should have a new window open with your living app! After you type a number, the app should display the square root of that number.\nCongratulations! You’ve successfully completed a Shiny app!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Overview",
    "section": "",
    "text": "Welcome to the 2022 All Scientists’ Meeting workshop “Shiny Apps for Sharing Science”! We are excited to have you with us for this training whether you are a veteran R Shiny user or this is your first foray into the world of Shiny! The link to the workshop schedule in Sched (ASM’s scheduling site) is included here.\n\nWe will be demonstrating the fundamentals of R Shiny using RStudio today so we suggest that you download R and download RStudio before the workshop. If your current RStudio version (see “About RStudio” in the top menubar) begins with anything earlier than “2020…”, we recommend updating RStudio. If your R version begins with anything other than “4…” we recommend you update R. These steps ensure that all R packages will behave as expected and we know where any needed RStudio buttons are on your machine if you require assistance.\n\n\nWe aim to make this training fun and interactive so please reach out if you have any questions before, during, or after this workshop! Our contact information is listed below:\nGabe De La Rosa: delarosa@nceas.ucsb.edu\nFrancisco J. Guerrero: francisco.guerrero@pnnl.gov\nNick J. Lyon: lyon@nceas.ucsb.edu"
  },
  {
    "objectID": "index.html#agenda",
    "href": "index.html#agenda",
    "title": "Overview",
    "section": "Agenda*",
    "text": "Agenda*\n*Note that this agenda is subject to change as we would rather move at a pace that is comfortable for everyone rather than covering all of our planned content if it means leaving some people behind.\n10:30a (PT) - Introductions & Workshop Overview\n10:40a - Welcome to the Wonderland of R Shiny\n10:50a - Core Shiny Structure (User Interface vs. Server)\n11:15a - Labels & Headers\n11:30a - Shiny App Layouts\n11:45a - Debrief\n11:55a - Evaluation\n12:00p - Done!\n\n\nFeel free to grab us after the workshop if you have questions or just want to keep the conversation going!"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Content Creators",
    "section": "",
    "text": "This workshop was created and facilitated by a dynamic team that is here to assist you before, during, and after your attendance at the workshop! To learn a bit more about us, see our bios and relevant links below."
  },
  {
    "objectID": "about.html#gabe-de-la-rosa",
    "href": "about.html#gabe-de-la-rosa",
    "title": "Content Creators",
    "section": "Gabe De La Rosa",
    "text": "Gabe De La Rosa\ngabrieldelarosa.com –  gdlr.github.io –  @gabe_de_la – delarosa@nceas.ucsb.edu\n\nGabe is the Digital Communications Coordinator for the Long-Term Ecological Research Network. He learned R Shiny as a masters student at UCSB’s Bren School of Environmental Science and Management, and most recently built a shiny app that displays an interactive map of LTER sites."
  },
  {
    "objectID": "about.html#francisco-j.-guerrero",
    "href": "about.html#francisco-j.-guerrero",
    "title": "Content Creators",
    "section": "Francisco J. Guerrero",
    "text": "Francisco J. Guerrero\n guerrero-fj –  @fjguerrerob – francisco.guerrero@pnnl.gov\n\nFrancisco J. Guerrero is the Science and Communication Research Associate for the Integrated, Coordinated, Open, and Networked-ICON Science Cooperative at PNNL. He is a watershed ecologist and a science communicator. since 2004, Francisco has been studying land to ocean carbon fluxes in small mountainous river systems. In his parallel role as communicator (since 2014), he has designed and implemented communication infrastructure (workshops, panels, working groups facilitation, etc.) at research-driven organizations from regional to national levels (e.g. universities, state agencies, and national research centers). Currently, Francisco is creating workflows for scientists and knowledge workers to integrate strategic communication tools along the scientific production lifecycle (from ideation to publication)."
  },
  {
    "objectID": "about.html#nick-j.-lyon",
    "href": "about.html#nick-j.-lyon",
    "title": "Content Creators",
    "section": "Nick J. Lyon",
    "text": "Nick J. Lyon\nnjlyon0.github.io –  njlyon0 –  @scilyon – lyon@nceas.ucsb.edu\n\nNick is a member of the Scientific Computing Support Team at NCEAS. He learned R Shiny in order to build the Herbivory Variability Network’s data submission portal ( repository linked here) but has since gained a broader appreciation for the value of Shiny apps in supporting many aspects of data visualization and wrangling. In particular, Nick recently developed a Shiny app to allow non-R users to explore his lterpalettefinder R package without needing to “speak” R ( repository linked here). Nick completed his M.Sc. in Ecology and Evolutionary Biology at Iowa State University."
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "Example Data",
    "section": "",
    "text": "The Long Term Ecological Research program (LTER) Network has recently created an R package containing example datasets from some of the LTER sites called lterdatasampler. The goal of lterdatasampler is to provide tidy versions of datasets from LTER sites for use in teaching and training contexts (like this workshop!). Eventually this package will contain datasets from each of the 28 extant LTER sites so be sure to check back often for updates as those data are integrated.\nFor this workshop, we’ll be using one of the datasets in this package to give our apps something to work with. Let’s explore that more fully below."
  },
  {
    "objectID": "data.html#andrews-forest-data",
    "href": "data.html#andrews-forest-data",
    "title": "Example Data",
    "section": "Andrews Forest Data",
    "text": "Andrews Forest Data\nSpecifically, we’ll be using the Andrews Forest (“AND”) LTER data. This dataset contains the length and width measurements of Cutthroat trout and salamanders found in Mack Creek at Andrews Forest.\nTo access this data, we’ll need to install the lterdatasampler dataset and we’ll also want both the tidyverse and librarian packages as well (for data wrangling and package installation convenience respectively).\n\n# install.packages(\"librarian\")\nlibrarian::shelf(lter/lterdatasampler, tidyverse)\n\nOnce we have the packages that we need, we can retrieve the data and take a look at it.\n\n# Load the data from AND\nand_data <- lterdatasampler::and_vertebrates\n\n# Take a quick look at it\ndplyr::glimpse(and_data)\n\nRows: 32,209\nColumns: 16\n$ year        <dbl> 1987, 1987, 1987, 1987, 1987, 1987, 1987, 1987, 1987, 1987…\n$ sitecode    <chr> \"MACKCC-L\", \"MACKCC-L\", \"MACKCC-L\", \"MACKCC-L\", \"MACKCC-L\"…\n$ section     <chr> \"CC\", \"CC\", \"CC\", \"CC\", \"CC\", \"CC\", \"CC\", \"CC\", \"CC\", \"CC\"…\n$ reach       <chr> \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"…\n$ pass        <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ unitnum     <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2…\n$ unittype    <chr> \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\"…\n$ vert_index  <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1, …\n$ pitnumber   <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ species     <chr> \"Cutthroat trout\", \"Cutthroat trout\", \"Cutthroat trout\", \"…\n$ length_1_mm <dbl> 58, 61, 89, 58, 93, 86, 107, 131, 103, 117, 100, 127, 99, …\n$ length_2_mm <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ weight_g    <dbl> 1.75, 1.95, 5.60, 2.15, 6.90, 5.90, 10.50, 20.60, 9.55, 13…\n$ clip        <chr> \"NONE\", \"NONE\", \"NONE\", \"NONE\", \"NONE\", \"NONE\", \"NONE\", \"N…\n$ sampledate  <date> 1987-10-07, 1987-10-07, 1987-10-07, 1987-10-07, 1987-10-0…\n$ notes       <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n\n\n\nAND Data Dictionary\nInformation about the data in AND can be accessed by running ?and_vertebrates but for simplicity’s sake, the columns and their meanings are recapitulated here as well.\n\nyear – number – observation year\nsitecode – character – abbreviated name of sample area\nsection – character – section of Mack Creek CC = clear cut forest, OG = old growth forest upstream\nreach – character – reach sampled from each section; L = lower reach (0 - 50 meters), M = middle reach (50 - 100 meters), U = upper reach (100 - 150 meters))\npass – number – electroshocking pass number, either 1 or 2\nunitnum – number – channel unit number\nunittype – character – channel unit classification type (C = cascade, I = riffle, IP = isolated pool (not connected to channel), P = pool, R = rapid, S = step (small falls), SC = side channel, NA = not sampled by unit)\nvert_index – number – unique index for each vertebrate\npitnumber – number – unique tag number embedded into vertebrate (tagging started in 2007)\nspecies – character – species measured\nlength_1_mm – number – vertebrate length in millimeters; total or snout-fork length for trout, and snout-vent length for salamanders\nlength_2_mm – number – snout-tail length in millimeters (for Coastal giant salamander only)\nweight_g – number – vertebrate mass in grams\nclip – character – fin clip type for cutthroat trout, ended in 2006 (LV = left ventral fin; LVRV = left and right ventral fins; RV = right ventral fin; NONE = no ventral fin clip)\nsampledate – date – date of observation\nnotes – character – additional comments\n\nWe may not use all of these columns today but your app could rely on any of them that you so choose!"
  }
]