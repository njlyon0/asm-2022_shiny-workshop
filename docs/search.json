[
  {
    "objectID": "core_shiny.html",
    "href": "core_shiny.html",
    "title": "Shiny Architecture",
    "section": "",
    "text": "Every R Shiny app–no matter how nuanced and visually appealing–is composed of three components:\n\nUser Interface (“UI”)\nServer\nshinyApp R function that binds the UI and server together\n\nLet’s delve into each of these in greater detail to better understand how they collectively make up a Shiny app.\nBefore we can do that however, we need a few key R packages installed, namely: shiny and (for convenience) htmltools. shiny is, perhaps unsurprisingly, the core workhorse package of most Shiny apps. There are other supporting packages you may decide to use in the future but shiny is a great place to start. htmltools contains some helpful secondary functions that make formatting headings and labels within an app more developer-friendly (you are the developer in this case!).\n\n# install.packages(\"librarian\")\nlibrarian::shelf(htmltools, shiny)\n\nWith those two packages installed, we can continue."
  },
  {
    "objectID": "core_shiny.html#user-interface",
    "href": "core_shiny.html#user-interface",
    "title": "Shiny Architecture",
    "section": "User Interface",
    "text": "User Interface\nThe User Interface (“UI”) is everything that you see in a functioning R Shiny app. This includes both the things that users can interact with (check boxes, text fields, etc.) and the things that user’s inputs create or modify (plots, printed messages, etc.).\nFrom the coding side of things, the UI includes all of the inputs and outputs of a given app. However, the UI does not include any code that turns inputs into outputs. We’ll cover that part momentarily, but an example of a UI element will be helpful here.\n\nUI Example\nLet’s imagine that we wanted to make an app with a single check box that users can either check or uncheck. To do this, we would have to define the check box in our app’s UI like so:\n\n# `fluidPage` is the wrapper for all the UI bits\nmy_ui <- fluidPage(\n  \n    # We can then create out checkbox\n    checkboxInput(inputId = \"my_checkbox\",\n                  label = \"Check me!\"),\n      \n    # And print the checkbox's output\n    \"The box is checked\",\n    verbatimTextOutput(outputId = \"my_checkbox_out\")\n    \n) # Close `fluidPage` parentheses\n\nAfter running that code, you should have an object called my_ui in your Environment. Notice though that there is no app yet, that’s because we still need to tell our app what to do with that check box and then tell R that the UI + server is an app! Also, crucially, even though we defined an output here in our UI, the server is where we’ll tell the app how to turn the input into the output.\nThree quick notes on the UI code:\n\nThe type of UI element is defined by which ...Input function you use. In the above example, we used checkboxInput so our app will give us a checkbox. If you wanted a numeric slider instead, you’d need to use sliderInput\n\nIf you downloaded all of the contents of this workshop’s GitHub repository, check out the “ui_elements.R” script for an example of some of the more common UI inputs\n\nNotice how after each bit of the UI (the checkbox, some text, and the output) there is a comma (,) but they are otherwise all just loose inside of the fluidPage parentheses\n\nThis syntax is key to the flexibility of Shiny apps because you can add any number of things and they’ll show up in the app (we’ll cover defining app layouts later)\n\nNot a syntax note per se but be careful with matching your parentheses!\n\nShiny apps (particularly the UI) can be many lines and it is easy to forget to close all the parentheses. We recommend turning on “Rainbow parentheses” in RStudio’s preferences to help make this easier\nRStudio -> Preferences -> Code -> Display -> Rainbow parentheses (checkbox)"
  },
  {
    "objectID": "core_shiny.html#server",
    "href": "core_shiny.html#server",
    "title": "Shiny Architecture",
    "section": "Server",
    "text": "Server\nThe server is the “behind the curtain” part of a Shiny app. The server receives all inputs from the User Interface, creates the outputs you define from those inputs, and finally returns the outputs to the UI so that they can be displayed. Unlike the UI, the server only creates outputs from inputs and is not visible to users of the app.\nIn terms of code, the server is actually one big function that accepts UI inputs and performs whatever operation(s) you specify. If you don’t usually write your own functions, don’t worry! See the example below:\n\nServer Example\nReturning to our growing app, let’s tell the server how to handle our checkbox.\n\n# Begin by defining the server function\nmy_server <- function(input, output){\n  \n  # Let's take the checkbox input and print it\n  output$my_checkbox_out <- renderPrint({ input$my_checkbox })\n  \n} # Close the server's curly brace\n\nOnce you run that you should have a function in your environment called my_server but still no app! We are nearly there so bear with us!\nNotes on server code:\n\nPutting function(input, output) tells the server that it should expect things called input and things called output\n\nMissing either of these will make your app not know how to handle one or both\n\nNotice how the input$... and output$... names are exact matches for what we put as the inputId and outputId in the UI\n\nThis is no accident! In the UI, in/outputs are given IDs, in the server they are placed into intermediary in/output objects"
  },
  {
    "objectID": "core_shiny.html#combining-ui-and-server",
    "href": "core_shiny.html#combining-ui-and-server",
    "title": "Shiny Architecture",
    "section": "Combining UI and Server",
    "text": "Combining UI and Server\nThe final step to bringing our app to life is to tell R that this is a Shiny app. This “telling” involves both using the shinyApp function and telling that function the name of your UI object and server function. R Shiny has made this step really streamlined which is convenient for us!\n\nRun App Example\nDouble check that your Environment includes both the my_ui and my_server objects. If you are missing one or both, re-run the corresponding code chunk above. Once you have both objects, run the following code.\n\nshinyApp(ui = my_ui, server = my_server)\n\nOnce you run this line, you should have a new window open with your living app! If you check the box the app should say “TRUE” and if you uncheck it the app should say “FALSE”.\nCongratulations! You’ve successfully completed a Shiny app!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Overview",
    "section": "",
    "text": "Welcome to the 2022 All Scientists’ Meeting workshop “Shiny Apps for Sharing Science”! We are excited to have you with us for this training whether you are a veteran R Shiny user or this is your first foray into the world of Shiny! The link to the workshop schedule in Sched (ASM’s scheduling site) is included here.\n\nWe will be demonstrating the fundamentals of R Shiny using RStudio today so we suggest that you download R and download RStudio before the workshop. If your current RStudio version (see “About RStudio” in the top menubar) begins with anything earlier than “2020…”, we recommend updating RStudio. If your R version begins with anything other than “4…” we recommend you update R. These steps ensure that all R packages will behave as expected and we know where any needed RStudio buttons are on your machine if you require assistance.\n\n\nWe aim to make this training fun and interactive so please reach out if you have any questions before, during, or after this workshop! Our contact information is listed below:\nGabe De La Rosa: delarosa@nceas.ucsb.edu\nFrancisco J. Guerrero: francisco.guerrero@pnnl.gov\nNick J. Lyon: lyon@nceas.ucsb.edu"
  },
  {
    "objectID": "index.html#agenda",
    "href": "index.html#agenda",
    "title": "Overview",
    "section": "Agenda*",
    "text": "Agenda*\n*Note that this agenda is subject to change as we would rather move at a pace that is comfortable for everyone rather than covering all of our planned content if it means leaving some people behind.\n10:30a (PT) - Introductions & Workshop Overview\n10:40a - Welcome to the Wonderland of R Shiny\n10:50a - Core Shiny Structure (User Interface vs. Server)\n11:15a - Labels & Headers\n11:30a - Shiny App Layouts\n11:45a - Debrief\n11:55a - Evaluation\n12:00p - Done!\n\n\nFeel free to grab us after the workshop if you have questions or just want to keep the conversation going!"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Content Creators",
    "section": "",
    "text": "This workshop was created and facilitated by a dynamic team that is here to assist you before, during, and after your attendance at the workshop! To learn a bit more about us, see our bios and relevant links below."
  },
  {
    "objectID": "about.html#gabe-de-la-rosa",
    "href": "about.html#gabe-de-la-rosa",
    "title": "Content Creators",
    "section": "Gabe De La Rosa",
    "text": "Gabe De La Rosa\ngabrieldelarosa.com –  gdlr.github.io –  @gabe_de_la – delarosa@nceas.ucsb.edu\n\nGabe is the Digital Communications Coordinator for the Long-Term Ecological Research Network. He learned R Shiny as a masters student at UCSB’s Bren School of Environmental Science and Management, and most recently built a shiny app that displays an interactive map of LTER sites."
  },
  {
    "objectID": "about.html#francisco-j.-guerrero",
    "href": "about.html#francisco-j.-guerrero",
    "title": "Content Creators",
    "section": "Francisco J. Guerrero",
    "text": "Francisco J. Guerrero\n guerrero-fj –  @fjguerrerob – francisco.guerrero@pnnl.gov\n\nFrancisco J. Guerrero is the Science and Communication Research Associate for the Integrated, Coordinated, Open, and Networked-ICON Science Cooperative at PNNL. He is a watershed ecologist and a science communicator. since 2004, Francisco has been studying land to ocean carbon fluxes in small mountainous river systems. In his parallel role as communicator (since 2014), he has designed and implemented communication infrastructure (workshops, panels, working groups facilitation, etc.) at research-driven organizations from regional to national levels (e.g. universities, state agencies, and national research centers). Currently, Francisco is creating workflows for scientists and knowledge workers to integrate strategic communication tools along the scientific production lifecycle (from ideation to publication)."
  },
  {
    "objectID": "about.html#nick-j.-lyon",
    "href": "about.html#nick-j.-lyon",
    "title": "Content Creators",
    "section": "Nick J. Lyon",
    "text": "Nick J. Lyon\nnjlyon0.github.io –  njlyon0 –  @scilyon – lyon@nceas.ucsb.edu\n\nNick is a member of the Scientific Computing Support Team at NCEAS. He learned R Shiny in order to build the Herbivory Variability Network’s data submission portal ( repository linked here) but has since gained a broader appreciation for the value of Shiny apps in supporting many aspects of data visualization and wrangling. In particular, Nick recently developed a Shiny app to allow non-R users to explore his lterpalettefinder R package without needing to “speak” R ( repository linked here). Nick completed his M.Sc. in Ecology and Evolutionary Biology at Iowa State University."
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "Data Source",
    "section": "",
    "text": "The Long Term Ecological Research program (LTER) Network has recently created an R package containing example datasets from some of the LTER sites called lterdatasampler. The goal of lterdatasampler is to provide tidy versions of datasets from LTER sites for use in teaching and training contexts (like this workshop!). Eventually this package will contain datasets from each of the 28 extant LTER sites so be sure to check back often for updates as those data are integrated.\nFor this workshop, we’ll be using one of the datasets in this package to give our apps something to work with. Let’s explore that more fully below."
  },
  {
    "objectID": "data.html#andrews-forest-data",
    "href": "data.html#andrews-forest-data",
    "title": "Data Source",
    "section": "Andrews Forest Data",
    "text": "Andrews Forest Data\nSpecifically, we’ll be using the Andrews Forest (“AND”) LTER data. This dataset contains the length and width measurements of Cutthroat trout and salamanders found in Mack Creek at Andrews Forest.\nTo access this data, we’ll need to install the lterdatasampler dataset and we’ll also want both the tidyverse and librarian packages as well (for data wrangling and package installation convenience respectively).\n\n# install.packages(\"librarian\")\nlibrarian::shelf(lter/lterdatasampler, tidyverse)\n\nOnce we have the packages that we need, we can retrieve the data and take a look at it.\n\n# Load the data from AND\nand_data <- lterdatasampler::and_vertebrates\n\n# Take a quick look at it\ndplyr::glimpse(and_data)\n\nRows: 32,209\nColumns: 16\n$ year        <dbl> 1987, 1987, 1987, 1987, 1987, 1987, 1987, 1987, 1987, 1987…\n$ sitecode    <chr> \"MACKCC-L\", \"MACKCC-L\", \"MACKCC-L\", \"MACKCC-L\", \"MACKCC-L\"…\n$ section     <chr> \"CC\", \"CC\", \"CC\", \"CC\", \"CC\", \"CC\", \"CC\", \"CC\", \"CC\", \"CC\"…\n$ reach       <chr> \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"…\n$ pass        <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ unitnum     <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2…\n$ unittype    <chr> \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\"…\n$ vert_index  <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1, …\n$ pitnumber   <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ species     <chr> \"Cutthroat trout\", \"Cutthroat trout\", \"Cutthroat trout\", \"…\n$ length_1_mm <dbl> 58, 61, 89, 58, 93, 86, 107, 131, 103, 117, 100, 127, 99, …\n$ length_2_mm <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ weight_g    <dbl> 1.75, 1.95, 5.60, 2.15, 6.90, 5.90, 10.50, 20.60, 9.55, 13…\n$ clip        <chr> \"NONE\", \"NONE\", \"NONE\", \"NONE\", \"NONE\", \"NONE\", \"NONE\", \"N…\n$ sampledate  <date> 1987-10-07, 1987-10-07, 1987-10-07, 1987-10-07, 1987-10-0…\n$ notes       <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n\n\n\nAND Data Dictionary\nInformation about the data in AND can be accessed by running ?and_vertebrates but for simplicity’s sake, the columns and their meanings are recapitulated here as well.\n\nyear – number – observation year\nsitecode – character – abbreviated name of sample area\nsection – character – section of Mack Creek CC = clear cut forest, OG = old growth forest upstream\nreach – character – reach sampled from each section; L = lower reach (0 - 50 meters), M = middle reach (50 - 100 meters), U = upper reach (100 - 150 meters))\npass – number – electroshocking pass number, either 1 or 2\nunitnum – number – channel unit number\nunittype – character – channel unit classification type (C = cascade, I = riffle, IP = isolated pool (not connected to channel), P = pool, R = rapid, S = step (small falls), SC = side channel, NA = not sampled by unit)\nvert_index – number – unique index for each vertebrate\npitnumber – number – unique tag number embedded into vertebrate (tagging started in 2007)\nspecies – character – species measured\nlength_1_mm – number – vertebrate length in millimeters; total or snout-fork length for trout, and snout-vent length for salamanders\nlength_2_mm – number – snout-tail length in millimeters (for Coastal giant salamander only)\nweight_g – number – vertebrate mass in grams\nclip – character – fin clip type for cutthroat trout, ended in 2006 (LV = left ventral fin; LVRV = left and right ventral fins; RV = right ventral fin; NONE = no ventral fin clip)\nsampledate – date – date of observation\nnotes – character – additional comments\n\nWe may not use all of these columns today but your app could rely on any of them that you so choose!"
  }
]