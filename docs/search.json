[
  {
    "objectID": "deploy.html",
    "href": "deploy.html",
    "title": "Deploying your app",
    "section": "",
    "text": "We won’t cover deploying a shiny app in this session—it’s a bit of a convoluted process, and the risk of everyone in the workshop hitting problems is too high. That being said, deploying is incredibly straightforward once you set everything up right.\nThe most common way to deploy apps is via shinyapps.io. Shiny lets users host apps for free, but there some limits on size, server allocation, etc. This method works wonders for most users. Most won’t want to look into other options, unless they’re creating an app for deployment in a very professional or high-user environment.\nA somewhat comprehensive guide to deployment is available here: https://shiny.rstudio.com/articles/shinyapps.html\nYou can see demo apps deployed on shinyapps.io here: Workshop Example App LTER Map"
  },
  {
    "objectID": "core_shiny.html",
    "href": "core_shiny.html",
    "title": "Shiny 101",
    "section": "",
    "text": "Shiny allows developers (ie, you) to package complicated and dynamic data analysis, exploration, and visualization in a user frendly website. It’s a great way to share data and allow other users to play or explore it for themselves. It’s a useful tool to share results with stakeholders or with colleagues, allowing them to compare different scenarios or choose different parameters.\nShiny apps harness the power of R, from data wrangling and visualization to spatial analysis. But they do so in a controlled way, where an end user sees zero code, but can run analyses by selecting options or changing inputs. Shiny is science communication at its most flexible."
  },
  {
    "objectID": "core_shiny.html#fundamental-structure",
    "href": "core_shiny.html#fundamental-structure",
    "title": "Shiny 101",
    "section": "Fundamental Structure",
    "text": "Fundamental Structure\nEvery R Shiny app–no matter how nuanced and visually appealing–is composed of three components:\n\nUser Interface (“UI”)\nServer\nshinyApp R function that binds the UI and server together\n\nLet’s delve into each of these in greater detail to better understand how they collectively make up a Shiny app.\nBefore we can do that however, we need one key R package installed, namely: shiny. shiny is, perhaps unsurprisingly, the core workhorse package of most Shiny apps. One huge benefit of Shiny is that you can use any R package inside of a Shiny app, which makes things like manipulating data or plotting more familiar. However, the only required package to create a Shiny app is shiny.\n\n\n\n\n\n\n\n\n\n\n\n# install.packages(\"librarian\")\nlibrarian::shelf(shiny)\n\n\n\nWith that package installed, we can continue."
  },
  {
    "objectID": "core_shiny.html#user-interface-overview",
    "href": "core_shiny.html#user-interface-overview",
    "title": "Shiny 101",
    "section": "User Interface Overview",
    "text": "User Interface Overview\nThe User Interface (“UI”) is everything that you see in a functioning R Shiny app. In fact, you can create an entire, functioning shiny app only in the UI, with formatted text, images, links, et cetera. If you only code in the UI, you end up making a static web page, much like a “WYSWYG” editor (“What You See is What You Get”) like wordpress or drupal might generate.\nThe power of shiny comes when you let users interact with the data, and the app responds to their selections. This requires making reactive objects in the server, the key to unlocking the full power of shiny. We’ll dive into this connection later. For now, we focus on the UI.\nLet’s take a very basic example:\n\n\n\n\n\n\n\n\n\n\n\n# Define UI\nbasic_ui <- fluidPage(\n  \"Here's some text\"\n)\n\n\n\nHere, we just tell the UI that we want some text to display. fluidPage is a function in the shiny package that defines the page structure—there’s a few others, but fluidPage is a great default, because it’s incredibly flexible. It wraps the code for the entire app! We’ll worry about more complicated structure later.\nWe can add other elements, too:\n\n\n\n\n\n\n\n\n\n\n\nbasic_ui <- fluidPage(\n  titlePanel(\"A simple app\"),\n  \"Here's some text\",\n  img(src = \"https://lternet.edu/wp-content/themes/ndic/library/images/logo.svg\")\n)\n\n\n\nThe shiny package contains some convenient functions for formatting and placement. In this case, we used titlePanel to format some text as a title, and the img function to render an image from a source on the internet. If you want something to display, there’s likely a shiny function that let’s you do it easily."
  },
  {
    "objectID": "core_shiny.html#non-reactive-server-app",
    "href": "core_shiny.html#non-reactive-server-app",
    "title": "Shiny 101",
    "section": "Non-Reactive Server & App",
    "text": "Non-Reactive Server & App\nIf we want to run the app, we need to define both the server, and then run the shinyApp function that tells R to stitch it all together. In this case, our server is empty, because we don’t actually need the app to do anything behind the hood yet. Note that the server is just a user defined function with the variables input and output — not a pre defined function.\nAt the end, we use the shinyApp function to tell R to compile our server and ui into an app.\n\n\n\n\n\n\n\n\n\n\n\n# Define server\nbasic_server <- function(input, output){ }\n\n# Create the app\nshinyApp(ui = basic_ui, server = basic_server)\n\n\n\nIf you know a bit of web development, the app you create might look like what you get when you code HTML without any CSS styling. A huge benefit of shiny is that we can actually define the layout and styling within the UI, alongside the actual objects (text, images)—though we did minimal formatting in this case. More on this later—and if these last two sentences make no sense, it’s totally fine to ignore them and move on!"
  },
  {
    "objectID": "core_shiny.html#creating-a-reactive-ui",
    "href": "core_shiny.html#creating-a-reactive-ui",
    "title": "Shiny 101",
    "section": "Creating a Reactive UI",
    "text": "Creating a Reactive UI\nSo far, we haven’t made Shiny do anything very useful—and it’s certainly more convoluted than a WYSWYG editor. But say we had a goal of creating an interactive app? Maybe radio buttons where a user can select an option, then see a different output based on that selection?\nIf the UI defines what a user sees, we want them to see two things: the radio buttons, but also the output—maybe some text in this case—that the buttons generate.\nThis concept is key: the UI includes both the things that users can interact with (check boxes, text fields, etc.) and the things that user’s inputs create or modify (plots, printed messages, etc.).\nLet’s start coding this up, starting with adding the buttons:\n\n\n\n\n\n\n\n\n\n\n\n# Define the UI\nreactive_ui <- fluidPage(\n  \n    # Let's create the input\n  numericInput(inputId = \"my_input\",\n               label = \"Type a number\",\n               value = 25)\n  \n)\n\n\n\nNotice that this also uses a convenient function in the shiny package: numericInput. There are many functions that let you add interactive objects, which shiny users generally call widgets. We can internally name the buttons using the inputId argument, which lets us refer to it (and also the output it generates!) in later code.\nLet’s also define where we want the results of our selection to show up. The syntax mirrors defining an input:\n\n\n\n\n\n\n\n\n\n\n\n# Define the UI\nreactive_ui <- fluidPage(\n  \n    # Let's create the radio buttons\n  numericInput(inputId = \"my_input\",\n               label = \"Type a number\",\n               value = 25),\n  \n    # And print the output\n  \"Square root is: \",\n  textOutput(outputId = \"my_output\")\n  \n  )  \n\n\n\nWe similarly want to define the output ID so we can refer to it later. The inputId and outputId arguments let us connect a specific input to a specific output in the server, which we’ll do in a moment.\nThree quick notes on the UI code:\n\nThe type of UI element is defined by which *Input function you use. In the above example, we used numericInput so our app will give us a field that accepts numbers. If you wanted a checkbox instead, you’d need to use checkboxInput\n\nIf you downloaded all of the contents of this workshop’s GitHub repository, check out the “ui_elements.R” script for an example of some of the more common UI inputs\n\nNotice how after each bit of the UI (the input, some text, and the output) there is a comma (,) but they are otherwise all just loose inside of the fluidPage parentheses\n\nThis syntax is key to the flexibility of Shiny apps because you can add any number of things and they’ll show up in the app (we’ll cover defining app layouts later)\n\nNot a syntax note per se but be careful with matching your parentheses!\n\nShiny apps (particularly the UI) can be many lines and it is easy to forget to close all the parentheses. We recommend turning on “Rainbow parentheses” in RStudio’s preferences to help make this easier\nRStudio -> Preferences -> Code -> Display -> Rainbow parentheses (check the checkbox)"
  },
  {
    "objectID": "core_shiny.html#creating-a-reactive-server",
    "href": "core_shiny.html#creating-a-reactive-server",
    "title": "Shiny 101",
    "section": "Creating a Reactive Server",
    "text": "Creating a Reactive Server\nOur new app is interactive, so we now actually have to put something in the server function!\nThe server is the “behind the curtain” part of a Shiny app. The server receives all inputs from the User Interface, then uses the code that you write in the server to create the outputs based on the inputs. These outputs are then returned to the UI so that the user can see the result of their selection.\nIn terms of code, the server is actually one big function that accepts UI inputs and performs whatever operation(s) you specify. If you don’t usually write your own functions, don’t worry! See the example below to help clarify these ideas:\n\nServer Example\nReturning to our growing app, let’s tell the server how to handle our inputs.\n\n\n\n\n\n\n\n\n\n\n\n# Define the server\nreactive_server <- function(input, output){\n  \n  # Reactively receive the input and take the square root\n  square_root <- reactive({\n    sqrt(input$my_input)\n  })\n  \n  # Now render that square root as an output\n  output$my_output <- renderText( square_root() )\n  \n}\n\n\n\nThe syntax differs from non-Shiny R code, so let’s break it down.\nWe first need to define where we want the output to display. Remember those names we gave the inputs and outputs in the UI? Here’s where they come in handy.\nTo start, we actually have to calculate the square root of whatever number the user inputs. Crucially, we want to take the square root every time the user changes that number. In Shiny’s terms, we want to reactively take the square root. In order to do this, we place the input$my_input inside of a “reactive consumer” (reactive({ ... })). This reactive consumer will automatically detect changes to whatever is inside of the nest parentheses/curly braces and will re-run itself as needed. Objects created by reactive consumers are very similar to functions so they need empty parentheses next to them in subsequent reference. See the square_root() syntax inside of the renderText parentheses?\nNext, we know that we want to create our output called my_output. Every output in the server starts with output$, and the ID of the output widget follows the dollar sign. Think of this like a named object in R, to which we can assign to something. So, we start with output$my_output, followed by the assignment operator <-.\nMost often, you want to assign the output object to a bit of code that generates something. Shiny has it’s own set of functions that prepare objects for display in the UI, which all start with render* and usually finish with a descriptive term of the output. In this case, we’re just asking the app to render some text that tells us if the checkbox is checked, so we use… renderText! And in those parentheses, we know we want the output generated by our numeric input, so we refer to it using its name: input$my_input.\nNotes on server code:\n\nPutting function(input, output) tells the server that it should expect things called input and things called output\n\nMissing either of these will mean your app doesn’t know what to look for, and it won’t work\n\nNotice how the input$... and output$... names are exact matches for what we put as the inputId and outputId in the UI\n\nThis is no accident! In the UI, in/outputs are given IDs, in the server they are placed into intermediary in/output objects"
  },
  {
    "objectID": "core_shiny.html#assemble-the-reactive-app",
    "href": "core_shiny.html#assemble-the-reactive-app",
    "title": "Shiny 101",
    "section": "Assemble the Reactive App",
    "text": "Assemble the Reactive App\nDouble check that your Environment includes both the reactive_ui and reactive_server objects. If you are missing one or both, re-run the corresponding code chunk above. Once you have both objects, run the following code.\n\n\n\n\n\n\n\n\n\n\n\nshinyApp(ui = reactive_ui, server = reactive_server)\n\n\n\nOnce you run this line, you should have a new window open with your living app! After you type a number, the app should display the square root of that number.\nCongratulations! You’ve successfully completed a Shiny app!"
  },
  {
    "objectID": "byo.html",
    "href": "byo.html",
    "title": "Build Your Own!",
    "section": "",
    "text": "Now that we’ve covered the fundamental architecture of a Shiny app, let’s tackle creating an app together during this workshop. We will work together on this app but there a few core resources you may find useful later on or if you get ahead of the group. In particular:\n\nWe’ll use Andrews Forest data in our app so check out our description of those data in the “Example Data” tab\nIf you want to learn about headers and text formatting in a Shiny app, check out the “Labels & Headers” tab\nIf you’d like to experiment with Shiny’s UI built-in layout options, see the “Layouts” tab\n\nAn example of the app we will build (is found here)[https://lternetwork.shinyapps.io/asm_2022_shiny_workshop_full_app_deploy/?_ga=2.225078554.140765860.1663269972-218790057.1663269972].\nIn order to make sure we are all working with the same tools, be sure that you have the necessary R packages installed!\n\n\n\n\n\n\n\n\n\n\n\n# install.packages(\"librarian\")\nlibrarian::shelf(shiny, htmltools, tidyverse, leaflet, lter/lterdatasampler)"
  },
  {
    "objectID": "byo.html#creating-an-overview-tab",
    "href": "byo.html#creating-an-overview-tab",
    "title": "Build Your Own!",
    "section": "Creating an Overview Tab",
    "text": "Creating an Overview Tab\nLet’s say we want our app to first have an overview panel with information about the forest, a picture, and maybe the forest location. Shiny is very flexible, and there are several ways to scaffold pages, add images, etc. This is a good start!\n\nOverview Tab - UI\nThere are a few prebuilt functions in shiny that build slightly different pages. In the core shiny example, we used fluidPage, which automatically sizes items on a single page. For this example, we’ll use navbarPage function in the UI, which lets us add a navigation bar with different tabs that link to separately displayed pages. We start our UI scaffolding with navbarPage, and then we can build different tabs within tabPanel functions. Let’s start with two tabs: overview, which we’ll build now, then species weights, which we’ll build in a moment.\n\n\n\n\n\n\n\n\n\n\n\noverview_ui <- navbarPage(\n  # Title of the app\n  \"Andrews Forest\",\n    # Add the panels, with titles\n    tabPanel(\"Overview\"),\n    tabPanel(\"Species weights\")\n)\n\n# Nothing in the server yet...\noverview_server <- function(input, output){}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nshinyApp(ui = overview_ui, server = overview_server)\n\n\n\nPretty boring app, right? Let’s fill out that Overview tab with some more interesting stuff. First, we need to create some scaffolding to hold our content. I always start with fluidPage—but this time, it’s contained within the Overview tabPanel function. I already know we want a photo on the left, then some text on the right, with a map underneath it. So, I’ll first create a fluidRow, then two columns with different widths in the row. Column widths are divisions of 12 (don’t ask me why), so 4 and 8 seem appropriate.\nWe can add a title using titlePanel in the main fluidPage—and Shiny already knows where to put it and how to style it. Easy!\n\n\n\n\n\n\n\n\n\n\n\noverview_ui <- navbarPage(\n  \"Andrews Forest\",\n  \n  ## We're focused on this section\n    tabPanel(\"Overview\",\n      # Start scaffolding\n      fluidPage(\n          # Add title\n          titlePanel(\"Overview\"),\n          # Add a row to add things in\n          fluidRow(\n          # Then divide up the row into two columns, with width 4 and 8\n            column(4),\n            column(8)\n            )\n          )\n      ),\n\n    tabPanel(\"Species weights\",\n             fluidPage())\n)\n\n\n\nNow to actually add some content. Images hosted online are remarkably easy—Shiny can just point to the URL and display the image, no linking files needed, with the img function from htmltools.\n\n\n\n\n\n\n\n\n\n\n\nimg(src = \"https://lternet.edu/wp-content/uploads/2022/03/Lookout_Creek_in_the_HJ_Andrews_Experimental_Forest_Willamette_National_Forest_23908499686-1.jpg\",\n    width = \"100%\"))\n\n\n\nWe can add text and style it with other useful functions from htmltools. Let’s add two headings and some paragraph text:\n\n\n\n\n\n\n\n\n\n\n\nhtmltools::h2(\"About The Forest\"),\n\nhtmltools::p(\"The H.J. Andrews Experimental Forest (AND) LTER is located in the Cascade Range of Oregon, and consists of 6,400 ha of conifer forest, meadows, and stream ecosystems. This mountain landscape experiences episodic disturbances, including fires, floods, and landslides. The question central to AND LTER research is: How do climate, natural disturbance, and land use, as influenced by forest governance, interact with biodiversity, hydrology, and carbon and nutrient dynamics? Andrews LTER research illuminates the complexity of native, mountain ecosystems such as: forest stream interactions; roles of dead wood; and effects of forest harvest and disturbance on hydrology, vegetation, and biogeochemistry over multiple time scales. Andrews LTER research has also been central to informing regional and national forest policy. Future research will address ongoing change in streams, forests, climate, and governance.\"),\n\nhtmltools::h2(\"About This Project\"),\n\nhtmltools::p(\"This project demonstrates how a site might use Shiny apps to communicate results from their research\")),\n\n\n\nWhen we place these in the appropriate areas, this is what we get for the UI:\nNotice that we also put in a placeholder for the map using leafletOutput. We can’t build the map in the UI—that happens in the server, where all the behind the scenes code runs—but we can define a place for the output.\n\n\n\n\n\n\n\n\n\n\n\noverview_ui <- navbarPage(\n  \"Andrews Forest\",\n    tabPanel(\"Overview\",\n      fluidPage(\n          titlePanel(\"Overview\"),\n          \n          # This is the section we're focused on:\n          fluidRow(\n            column(4,\n                   # Add image\n                   img(src = \"https://lternet.edu/wp-content/uploads/2022/03/Lookout_Creek_in_the_HJ_Andrews_Experimental_Forest_Willamette_National_Forest_23908499686-1.jpg\",\n                       width = \"100%\")\n                   ) # Close column\n            ,\n            column(8,\n                   # Add some text within a row — this sets us up to add a map below the text\n                   fluidRow(\n                     h2(\"About The Forest\"),\n                     p(\"The H.J. Andrews Experimental Forest (AND) LTER is located in the Cascade Range of Oregon, and consists of 6,400 ha of conifer forest, meadows, and stream ecosystems. This mountain landscape experiences episodic disturbances, including fires, floods, and landslides. The question central to AND LTER research is: How do climate, natural disturbance, and land use, as influenced by forest governance, interact with biodiversity, hydrology, and carbon and nutrient dynamics? Andrews LTER research illuminates the complexity of native, mountain ecosystems such as: forest stream interactions; roles of dead wood; and effects of forest harvest and disturbance on hydrology, vegetation, and biogeochemistry over multiple time scales. Andrews LTER research has also been central to informing regional and national forest policy. Future research will address ongoing change in streams, forests, climate, and governance.\"),\n                     h2(\"About This Project\"),\n                     p(\"This project demonstrates how a site might use Shiny apps to communicate results from their research\")\n                     ), # Close row\n                   \n                   # And add a placeholder output where we want our map to go\n                   leafletOutput(\"andrews_map\", width = \"90%\", height = 350\n                                 )\n                   ) # Close column\n            )# Close fluidRow\n          ), # Close fluidPage\n    ), # Close Overview\n  \n    tabPanel(\"Species weights\")\n) # close navbarPage\n\n\n\n\n\nOverview Tab - Server\nWe actually need to put something in our server: the leaflet map! Working with spatial data and or leaflet is worth a lesson on it’s own and we won’t cover it here.\nOne takeaway is that Shiny plays very nicely with some other R packages—such as leaflet, plotly, or ggplot—and often has specified functions designed to render these objects, such as renderLeaflet. Lets build our server:\n\n\n\n\n\n\n\n\n\n\n\n# Define server logic required to draw a histogram\noverview_server <- function(input, output) {\n\n    # Map with marker at forest\n    output$andrews_map <- renderLeaflet({\n        leaflet() %>% \n          addTiles() %>% \n          addCircleMarkers(lng = -122.1641168884823, lat = 44.2310583215366, label = \"Andrews Forest\") %>% \n        addPopups(lng = -122.1641168884823, lat = 44.2310583215366, popup = \"<img src = 'https://andrewsforest.oregonstate.edu/sites/default/files/lter/images/logos/hja/newtlogo1.jpg', height = '30'> <b>Andrews Forest</b>\", options = popupOptions(closeButton = FALSE)) %>%\n        setView(-122.1641168884823, 44.2310583215366, zoom = 5)\n      \n    })\n}\n\n\n\nWhen we run the app, we can see the layout!\n\n\n\n\n\n\n\n\n\n\n\nshinyApp(ui = overview_ui, server = overview_server)"
  },
  {
    "objectID": "byo.html#creating-a-reactive-histogram",
    "href": "byo.html#creating-a-reactive-histogram",
    "title": "Build Your Own!",
    "section": "Creating a Reactive Histogram",
    "text": "Creating a Reactive Histogram\nHonestly, creating an overview page was nothing fancy—we just placed a few items on a page.\nShiny’s real power is letting users interact with data in real time. This is called reactivity in shiny lingo, and is the main reason most people learn and use R Shiny.\n\nReactive Tab - UI\nLet’s begin with a user interface. Reactivity happens completely in the server, so nothing tricky here. We just place our inputs in the Shiny scaffolding. In this case, we’re adding a dropdown menu, some selectable (radio) buttons, and our plot output.\n\n\n\n\n\n\n\n\n\n\n\nreactive_ui <- fluidPage(\n  \n  # Dropdown for watershed\n  selectInput(inputId = \"dropdown_site\",\n              label = \"Site\",\n              # Choices are \"All\" or `sitecode` values in data\n              choices = c(\"All\", unique(and_vertebrates$sitecode))),\n  \n  # Radio buttons for species\n  radioButtons(inputId = \"button_spp\",\n               label = \"Species\",\n               # The `setdiff(...)` is just to remove NAs\n               choices = setdiff(x = unique(and_vertebrates$species), y = NA)),\n  \n  # Create histogram output\n  plotOutput(outputId = \"hist_out\")\n  \n)\n\n\n\n\n\nReactive Tab - Server\nCreating the server is the tricky part. We want to take those inputs and use them to create a histogram.\nEnter reactivity, and reactive objects. Reactive objects are like empty boxes: we create them once, and then can fill them with a user’s selection when the time is right. Fortunately, Shiny takes care of much of the dirty work.\nReactive objects can contain anything–a plot, text, an image, a data frame, you name it. We just define it using the reactive({}) function.\nLet’s take our first example: we want an object to be the and_vertebrates data frame filtered by whatever the user selects via the radio buttons.\nThis looks like this:\n\n\n\n\n\n\n\n\n\n\n\nreactive_server <- function(input, output){\n  \n  # Subset dataframe to selected species\n  ## Must be done inside of \"reactive consumer\"\n  and_v2 <- reactive({\n    lterdatasampler::and_vertebrates %>%\n      dplyr::filter(species == input$button_spp)\n  })\n}\n\n\n\nRemember how we can refer to widget inputs using special syntax? We do that with input$button_spp in the above example to filter our data frame by our original example. input$button_spp seems like it should be a reactive object, right? Well, it kind of is—but Shiny has built in syntax that makes it intuitive to refer to.\nWe can add other reactivity based on the other inputs. See if you can figure out what’s going on below:\nOh, and when you want to use those reactive inputs in a plot, say? You need to refer to them in function syntax, such as and_v2. Without the tailing parentheses, Shiny won’t know what you’re referring to!\n\n\n\n\n\n\n\n\n\n\n\nreactive_server <- function(input, output){\n  \n  # Subset dataframe to selected species\n  and_v2 <- reactive({\n    lterdatasampler::and_vertebrates %>%\n      dplyr::filter(species == input$button_spp)\n  })\n  \n  # Subset dataframe to desired site\n  ## Also done in reactive consumer\n  and_actual <- reactive({\n    ## If site is \"All\" don't subset\n    if(input$dropdown_site == \"All\"){ \n      and_v2()\n      ## Otherwise, subset to selected site\n    } else { \n      and_v2() %>%\n        dplyr::filter(sitecode == input$dropdown_site) }\n  })\n  \n  # Assemble title from inputs to be more informative\n  hist_title <- reactive({\n      paste0(\"Histogram of \", tolower(input$button_spp),\n             \" weight\", \"\\n\", \"Site: \", input$dropdown_site)\n    })\n  \n  # Create a histogram of this content\n  output$hist_out <- renderPlot({\n    ## Uses the reactively-created weight\n    hist(x = and_actual()$weight_g,\n         ## And the reactively-created title!\n         main = hist_title(),\n         xlab = \"Weight (g)\")\n  })\n  \n}\n\n\n\nGenerate the app from the UI and server!\n\n\n\n\n\n\n\n\n\n\n\nshinyApp(ui = reactive_ui, server = reactive_server)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Overview",
    "section": "",
    "text": "Welcome to the 2022 All Scientists’ Meeting workshop “Shiny Apps for Sharing Science”! We are excited to have you with us for this training whether you are a veteran R Shiny user or this is your first foray into the world of Shiny! The link to the workshop schedule in Sched (ASM’s scheduling site) is included here.\n\nWe will be demonstrating the fundamentals of R Shiny using RStudio today so we suggest that you download R and download RStudio before the workshop.\n\nIf your RStudio version begins with anything earlier than “2020…”, we recommend updating RStudio (see “About RStudio” in the top menu bar).\nIf your R version begins with anything other than “4…” we recommend you update R.\n\nUpdating RStudio and R ensures that all R packages will behave as expected and we know where any needed RStudio buttons are on your machine if you require assistance.\nAlso, run the following code chunk to guarantee that you have all of the packages that you need.\n\n\n\n\n\n\n\n\n\n\n\n# Install the librarian package for easy package downloading\ninstall.packages(\"librarian\")\n\n# Use librarian to install the other packages that you need!\nlibrarian::shelf(shiny, htmltools, tidyverse, leaflet, lter/lterdatasampler)\n\n\n\n\n\nThe workshop guides participants through building their own Shiny App, modeled off of this one here: Shiny Workshop Example Aps. Participants will create the first two tabs of this app.\nWe have also created a handful of standalone scripts that create the apps we have embedded in this workshop website. You can access them via a dedicated GitHub repository and short descriptions of each app have been included in the README file at the bottom of that page.\nOr, if you are not an avid GitHub user (don’t worry if that is the case!) You can download all of those example app files by clicking here.\n\n\n\nWe aim to make this training fun and interactive so please reach out if you have any questions before, during, or after this workshop! Our contact information is listed below:\nGabe De La Rosa: delarosa@nceas.ucsb.edu\nFrancisco J. Guerrero: francisco.guerrero@pnnl.gov\nNick J. Lyon: lyon@nceas.ucsb.edu"
  },
  {
    "objectID": "index.html#agenda",
    "href": "index.html#agenda",
    "title": "Overview",
    "section": "Agenda*",
    "text": "Agenda*\n*Note that this agenda is subject to change. We would rather move at a pace that is comfortable for everyone rather than covering all of our planned content and leaving some people behind.\n10:30a (PT) - Introductions & Workshop Overview\n10:40a - Welcome to Shiny\n10:50a - Shiny 101\n11:15a - Build Your Own Shiny App I: Creating an Overview Tab\n11:30a - Build Your Own Shiny App II: Creating a Reactive Tab\n11:45a - Debrief\n11:55a - Evaluation\n12:00p - Done!\n\n\nFeel free to grab us after the workshop if you have questions or just want to keep the conversation going!"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Content Creators",
    "section": "",
    "text": "This workshop was created and facilitated by a dynamic team that is here to assist you before, during, and after your attendance at the workshop! To learn a bit more about us, see our bios and relevant links below."
  },
  {
    "objectID": "about.html#gabe-de-la-rosa",
    "href": "about.html#gabe-de-la-rosa",
    "title": "Content Creators",
    "section": "Gabe De La Rosa",
    "text": "Gabe De La Rosa\ngabrieldelarosa.com –  gdlr.github.io –  @gabe_de_la – delarosa@nceas.ucsb.edu\n\nGabe is the Digital Communications Coordinator for the Long-Term Ecological Research Network. He learned R Shiny as a masters student at UCSB’s Bren School of Environmental Science and Management, and most recently built a shiny app that displays an interactive map of LTER sites."
  },
  {
    "objectID": "about.html#francisco-j.-guerrero",
    "href": "about.html#francisco-j.-guerrero",
    "title": "Content Creators",
    "section": "Francisco J. Guerrero",
    "text": "Francisco J. Guerrero\nguerrero-fg.github.io –  guerrero-fj –  @fjguerrerob – francisco.guerrero@pnnl.gov\n\nFrancisco J. Guerrero is the Science and Communication Research Associate for the Integrated, Coordinated, Open, and Networked-ICON Science Cooperative at PNNL. He is a watershed ecologist and a science communicator. since 2004, Francisco has been studying land to ocean carbon fluxes in small mountainous river systems. In his parallel role as communicator (since 2014), he has designed and implemented communication infrastructure (workshops, panels, working groups facilitation, etc.) at research-driven organizations from regional to national levels (e.g. universities, state agencies, and national research centers). Currently, Francisco is creating workflows for scientists and knowledge workers to integrate strategic communication tools along the scientific production lifecycle (from ideation to publication)."
  },
  {
    "objectID": "about.html#nick-j.-lyon",
    "href": "about.html#nick-j.-lyon",
    "title": "Content Creators",
    "section": "Nick J. Lyon",
    "text": "Nick J. Lyon\nnjlyon0.github.io –  njlyon0 –  @scilyon – lyon@nceas.ucsb.edu\n\nNick is a member of the Scientific Computing Support Team at NCEAS. He learned R Shiny in order to build the Herbivory Variability Network’s data submission portal ( repository linked here) but has since gained a broader appreciation for the value of Shiny apps in supporting many aspects of data visualization and wrangling. In particular, Nick recently developed a Shiny app to allow non-R users to explore his lterpalettefinder R package without needing to “speak” R ( repository linked here). Nick completed his M.Sc. in Ecology and Evolutionary Biology at Iowa State University."
  },
  {
    "objectID": "labels.html",
    "href": "labels.html",
    "title": "Labels & Headers",
    "section": "",
    "text": "Adding labels or headers to a Shiny app is relatively straightforward because these are static elements. This means that they require neither user inputs nor modification by the server into an output. Labels live solely in the UI.\nBefore we can practice adding labels or headers though, we’ll need to install the package htmltools for convenient header functions. Also, because we are still making a Shiny app, we should confirm that we have the shiny package loaded and ready to go."
  },
  {
    "objectID": "labels.html#recreating-our-reactive-app",
    "href": "labels.html#recreating-our-reactive-app",
    "title": "Labels & Headers",
    "section": "Recreating our Reactive App",
    "text": "Recreating our Reactive App\n\n\n\n\n\n\n\n\n\n\n\n# install.packages(\"librarian\")\nlibrarian::shelf(shiny, htmltools)\n\n\n\nLet’s re-create our reactive app from the previous chapter of the workshop so that we can see how it must be modified to include labels or headers.\nFirst, create the UI:\n\n\n\n\n\n\n\n\n\n\n\n# Define the UI\nlabel_ui <- fluidPage(\n  \n  # Create the radio buttons\n  numericInput(inputId = \"my_input\",\n               label = \"Type a number\",\n               value = 25),\n  \n  # And print the output\n  \"Square root is: \",\n  textOutput(outputId = \"my_output\")\n  \n  )  \n\n\n\nOnce we have a UI, we need to define the server to tell the app how to transform the input(s) into output(s).\n\n\n\n\n\n\n\n\n\n\n\n# Define the server\nlabel_server <- function(input, output){\n  \n  # Let's take the numeric input and take the square root\n  output$my_output <- renderText( sqrt(input$my_input) )\n  \n}\n\n\n\nWith both the UI and the server defined, we can re-create our app from the previous chapter by using the shinyApp function:\n\n\n\n\n\n\n\n\n\n\n\nshinyApp(ui = label_ui, server = label_server)\n\n\n\nExcellent; we’ve successfully re-created our first reactive app! Now, let’s leverage the functions in htmltools to add some informative headers to help users navigate our app."
  },
  {
    "objectID": "labels.html#adding-headers-line-breaks-to-our-app",
    "href": "labels.html#adding-headers-line-breaks-to-our-app",
    "title": "Labels & Headers",
    "section": "Adding Headers & Line Breaks to our App",
    "text": "Adding Headers & Line Breaks to our App\nAs mentioned previously, adding headers is–arguably–one of the more straightforward operations in R Shiny because we need only modify the UI.\nLet’s add a top-level header to our app to welcome users to the app and while we’re at it, let’s add smaller headings above the input and output respectively to make the layout of the app clearer.\n\n\n\n\n\n\n\n\n\n\n\n# Define the UI\nlabel_ui <- fluidPage(\n  \n  # Add a top-level header\n  htmltools::h1(\"Square Root Calculator\"),\n  \n  # Now add a smaller header for the input\n  htmltools::h3(\"Enter a Number Below\"),\n  \n  # Create the radio buttons\n  numericInput(inputId = \"my_input\",\n               label = \"Type a number\",\n               value = 25),\n  \n  # Also include a smaller header for the output\n  htmltools::h3(\"See Answer Below\"),\n  \n  # And print the output\n  \"Square root is: \",\n  textOutput(outputId = \"my_output\")\n  \n  )  \n\n\n\nWith the UI modified, we can re-create the app (we don’t need to re-define the server because it hasn’t changed)\n\n\n\n\n\n\n\n\n\n\n\nshinyApp(ui = label_ui, server = label_server)\n\n\n\nhtmltools supports six levels of header where the function h1 creates the biggest header and h6 creates the smallest. htmltools also allows us to create visual breaks in our app (lines across the page, empty rows, etc.) that can be helpful in de-cluttering the visual presentation of our app.\nLet’s add two line breaks beneath the top-level header and one between the numericInput field and the h3 label beneath it.\n\n\n\n\n\n\n\n\n\n\n\n# Define the UI\nlabel_ui <- fluidPage(\n  \n  # Add a top-level header\n  htmltools::h1(\"Square Root Calculator\"),\n  \n  # Add two line breaks\n  htmltools::hr(),\n  htmltools::hr(),\n\n  # Now add a smaller header for the input\n  htmltools::h3(\"Enter a Number Below\"),\n  \n  # Create the radio buttons\n  numericInput(inputId = \"my_input\",\n               label = \"Type a number\",\n               value = 25),\n  \n  # Add a line break\n  htmltools::hr(),\n  \n  # Also include a smaller header for the output\n  htmltools::h3(\"See Answer Below\"),\n  \n  # And print the output\n  \"Square root is: \",\n  textOutput(outputId = \"my_output\")\n  \n  )  \n\n\n\nAnd re-create the app to see the update.\n\n\n\n\n\n\n\n\n\n\n\nshinyApp(ui = label_ui, server = label_server)"
  },
  {
    "objectID": "labels.html#adding-labels-to-our-app",
    "href": "labels.html#adding-labels-to-our-app",
    "title": "Labels & Headers",
    "section": "Adding Labels to our App",
    "text": "Adding Labels to our App\nLabels are simpler to add to a Shiny app than headers because they are essentially plain text. Technically, the text in our app “Square root is:” is a label!\nTo showcase this further though, we can add a label above the double line break explaining what this app does to future users. For simplicity’s sake, we can create the app and the new UI in the same code chunk below.\n\n\n\n\n\n\n\n\n\n\n\n# Define the UI\nlabel_ui <- fluidPage(\n  \n  # Add a top-level header\n  htmltools::h1(\"Square Root Calculator\"),\n  \n  # Add an app explanation as a label\n  \"Welcome! This app takes the square root of any number that you type into the box below (by using the R function 'sqrt').\",\n  \n  # Add two line breaks\n  htmltools::hr(),\n  htmltools::hr(),\n\n  # Now add a smaller header for the input\n  htmltools::h3(\"Enter a Number Below\"),\n  \n  # Create the radio buttons\n  numericInput(inputId = \"my_input\",\n               label = \"Type a number\",\n               value = 25),\n  \n  # Add a line break\n  htmltools::hr(),\n  \n  # Also include a smaller header for the output\n  htmltools::h3(\"See Answer Below\"),\n  \n  # And print the output\n  \"Square root is: \",\n  textOutput(outputId = \"my_output\")\n  \n  )\n\n# And re-create the app\nshinyApp(ui = label_ui, server = label_server)"
  },
  {
    "objectID": "labels.html#customizing-text",
    "href": "labels.html#customizing-text",
    "title": "Labels & Headers",
    "section": "Customizing Text",
    "text": "Customizing Text\nWhile we are on the subject of adding headers and labels we can also discuss how text formatting (e.g., bold, code, italic, etc.) can be implemented in a Shiny app.\nFor these operations we’ll return to htmltools. To show this, let’s make “Welcome!” bold, and put the R function sqrt in “code” font (i.e., how it appears here!).\n\n\n\n\n\n\n\n\n\n\n\n# Define the UI\nlabel_ui <- fluidPage(\n  \n  # Add a top-level header\n  htmltools::h1(\"Square Root Calculator\"),\n  \n  # Add an app explanation as a label\n  ## Put \"Welcome\" in bold\n  htmltools::strong(\"Welcome!\"),\n  ## Keep plain text in the label\n  \"This app takes the square root of any number that you type into the box below (by using the R function \",\n  ## Make the function name \"code formatted\"\n  htmltools::code(\"sqrt\"),\n  ## Close the sentence's parentheses in plain text\n  \").\",\n  \n  # Add two line breaks\n  htmltools::hr(),\n  htmltools::hr(),\n\n  # Now add a smaller header for the input\n  htmltools::h3(\"Enter a Number Below\"),\n  \n  # Create the radio buttons\n  numericInput(inputId = \"my_input\",\n               label = \"Type a number\",\n               value = 25),\n  \n  # Add a line break\n  htmltools::hr(),\n  \n  # Also include a smaller header for the output\n  htmltools::h3(\"See Answer Below\"),\n  \n  # And print the output\n  \"Square root is: \",\n  textOutput(outputId = \"my_output\")\n  \n  )\n\n# And re-create the app\nshinyApp(ui = label_ui, server = label_server)\n\n\n\nAs demonstrated above the strong function makes the text inside of it bold while the code function makes its text in ‘code style’."
  },
  {
    "objectID": "labels.html#nesting-label-functions",
    "href": "labels.html#nesting-label-functions",
    "title": "Labels & Headers",
    "section": "Nesting Label Functions",
    "text": "Nesting Label Functions\nAs with typical R functions, Shiny let’s you ‘nest’ functions around each other to apply multiple text-modifying effects to the same text.\nIn our app the welcome message is good but the font is a little small. Let’s make it a header but keep it smaller than our sub-headings for the input and output of the app.\n\n\n\n\n\n\n\n\n\n\n\n# Define the UI\nlabel_ui <- fluidPage(\n  \n  # Add a top-level header\n  htmltools::h1(\"Square Root Calculator\"),\n  \n  # Add an app explanation as a small(ish) header\n  htmltools::h4(\n    ## Put \"Welcome\" in bold\n  htmltools::strong(\"Welcome!\"),\n  ## Keep plain text in the label\n  \"This app takes the square root of any number that you type into the box below (by using the R function \",\n  ## Make the function name \"code formatted\"\n  htmltools::code(\"sqrt\"),\n  ## Close the sentence's parentheses in plain text\n  \").\"\n  ),\n  \n  # Add two line breaks\n  htmltools::hr(),\n  htmltools::hr(),\n\n  # Now add a smaller header for the input\n  htmltools::h3(\"Enter a Number Below\"),\n  \n  # Create the radio buttons\n  numericInput(inputId = \"my_input\",\n               label = \"Type a number\",\n               value = 25),\n  \n  # Add a line break\n  htmltools::hr(),\n  \n  # Also include a smaller header for the output\n  htmltools::h3(\"See Answer Below\"),\n  \n  # And print the output\n  \"Square root is: \",\n  textOutput(outputId = \"my_output\")\n  \n  )\n\n# And re-create the app\nshinyApp(ui = label_ui, server = label_server)\n\n\n\nGreat! By leveraging labels, headers, text customization, and line breaks we have started to create a visually-appealing and easily-navigable Shiny app!\nLet’s move on to experimenting with Shiny’s built-in app layouts."
  },
  {
    "objectID": "layouts.html",
    "href": "layouts.html",
    "title": "Layouts",
    "section": "",
    "text": "R Shiny apps come with several pre-built layouts stored as functions. As with labels and headers, layouts are exlcusively controlled in the UI. This makes choosing a layout a similar process to the labels and headers selection process so hopefully the examples below will feel familiar!\nAs before, we need to re-define our UI, server, and app.We will also need to make sure that both shiny and htmltools are loaded as our app now depends on both.\n\n\n\n\n\n\n\n\n\n\n\n# install.packages(\"librarian\")\nlibrarian::shelf(shiny, htmltools)\n\n\n\nOnce we have the packages that we need, re-create the UI we wound up with at the end of the “Labels and Headers” chapter.\n\n\n\n\n\n\n\n\n\n\n\n# Define the UI\ndefault_ui <- fluidPage(\n  \n  # Add a top-level header\n  htmltools::h1(\"Square Root Calculator\"),\n  \n  # Add an app explanation as a small(ish) header\n  htmltools::h4(\n  htmltools::strong(\"Welcome!\"),\n  \"This app takes the square root of any number that you type into the box below (by using the R function \",\n  htmltools::code(\"sqrt\"), \").\" ),\n  \n  # Add two line breaks\n  htmltools::hr(),\n  htmltools::hr(),\n\n  # Now add a smaller header for the input\n  htmltools::h3(\"Enter a Number Below\"),\n  \n  # Create the radio buttons\n  numericInput(inputId = \"my_input\",\n               label = \"Type a number\",\n               value = 25),\n  \n  # Add a line break\n  htmltools::hr(),\n  \n  # Also include a smaller header for the output\n  htmltools::h3(\"See Answer Below\"),\n  \n  # And print the output\n  \"Square root is: \",\n  textOutput(outputId = \"my_output\")\n  \n  )\n\n\n\nBuild the server again.\n\n\n\n\n\n\n\n\n\n\n\n# Define the server\nlayout_server <- function(input, output){\n  \n  # Let's take the numeric input and take the square root\n  output$my_output <- renderText( sqrt(input$my_input) )\n  \n}\n\n\n\nFinally, create the app!\n\n\n\n\n\n\n\n\n\n\n\nshinyApp(ui = default_ui, server = layout_server)\n\n\n\nThe layout we have used so far is the default for Shiny: a single fluid page where all content is stacked vertically (that’s what the fluidPage function in the first line of the UI defaults to). However, if desired, we can invoke one of shiny’s built-in functions for specifying different app layouts. Let’s experiment with (1) an app that has a sidebar versus a main panel and (2) an app where content is divided into tabs."
  },
  {
    "objectID": "layouts.html#layout---sidebar",
    "href": "layouts.html#layout---sidebar",
    "title": "Layouts",
    "section": "Layout - Sidebar",
    "text": "Layout - Sidebar\nA classic template for apps is to have a vertical sidebar (usually ~20-25% the width of the screen) and a main panel (the remaining width of the screen). This is a great layout if you want to include several user inputs in the sidebar and a single output that is modified by most or all of these inputs.\nThis is often used when a plot is generated in the main panel and the user can tweak several aspects of that plot in the sidebar. Let’s create a new UI using this layout to showcase this.\nWe need to use two new shiny functions to tell our app which UI content should be in the sidebar and which should be in the main panel: sidebarPanel and mainPanel.\n\n\n\n\n\n\n\n\n\n\n\n# Define the UI\nsidebar_ui <- fluidPage(\n  \n  # Add a top-level header\n  htmltools::h1(\"Square Root Calculator\"),\n  \n  # Add an app explanation as a small(ish) header\n  htmltools::h4(\n  htmltools::strong(\"Welcome!\"),\n  \"This app takes the square root of any number that you type into the box below (by using the R function \",\n  htmltools::code(\"sqrt\"), \").\" ),\n  \n  # Add two line breaks\n  htmltools::hr(),\n  htmltools::hr(),\n\n  # Let's start the sidebar here\n  sidebarPanel(\n  \n  # Now add a smaller header for the input\n  htmltools::h3(\"Enter a Number Below\"),\n  \n  # Create the radio buttons\n  numericInput(inputId = \"my_input\",\n               label = \"Type a number\",\n               value = 25),\n  \n  # Add a line break\n  htmltools::hr(),\n  \n  # And end the sidebar here\n  ),\n  \n  # Now start the main panel\n  mainPanel(\n  \n  # Also include a smaller header for the output\n  htmltools::h3(\"See Answer Below\"),\n  \n  # And print the output\n  \"Square root is: \",\n  textOutput(outputId = \"my_output\")\n  \n  # And end the main panel here\n  )\n  \n  # Then close the whole `fluidPage` parentheses\n  )\n\n\n\nNote that all UI elements within the sidebarPanel(...) parentheses will be in the sidebar and all elements in the mainPanel(...) parentheses will be in the main panel. By leaving our main header and explanation outside of both we guarantee that they can use the whole width of the screen and will be above the division between sidebar and main panel.\nNow that the UI has been defined, we can use the same server function and create our app with a new user interface.\n\n\n\n\n\n\n\n\n\n\n\nshinyApp(ui = sidebar_ui, server = layout_server)\n\n\n\nIf you run the above code on your computer you should see the sidebar to the left and the main panel to the right. They are stacked vertically when embedded in this web page because they sense the width of the screen is insufficient for side-by-side display."
  },
  {
    "objectID": "layouts.html#layout---tabs",
    "href": "layouts.html#layout---tabs",
    "title": "Layouts",
    "section": "Layout - Tabs",
    "text": "Layout - Tabs\nAnother viable layout is to place content in separate tabs that a user can navigate between. This is similar to the navbar of this website as all tab labels will be visible but only the content of the selected tab will be displayed.\nNote that because this is a layout change, the server function is still capable of using inputs from one or more tabs and creating outputs in other tabs entirely if desired. In our experience, multiple tabs are more frequently used to display separate datasets that are under a common umbrella (e.g., the data from several experiments conducted at the same site, etc.).\nIn order to use the tabs layout we need two new shiny functions: tabsetPanel and one use of tabPanel per tab you’d like in your app. See below for an example\n\n\n\n\n\n\n\n\n\n\n\n# Define the UI\ntab_ui <- fluidPage(\n  \n  # Add a top-level header\n  htmltools::h1(\"Square Root Calculator\"),\n  \n  # Let's start the tabs here\n  tabsetPanel(\n  \n  # Now we need to tell the app where each tab starts and stops\n  tabPanel(title = \"Welcome\",\n  \n  # Add an app explanation as a small(ish) header\n  htmltools::h4(\n  htmltools::strong(\"Welcome!\"),\n  \"This app takes the square root of any number that you type into the box below (by using the R function \",\n  htmltools::code(\"sqrt\"), \").\" ),\n  \n  # Add two line breaks\n  htmltools::hr(),\n  htmltools::hr(),\n  \n  # Close this tabPanel and start the next\n  ), tabPanel(title = \"Starting Number\",\n\n  # Now add a smaller header for the input\n  htmltools::h3(\"Enter a Number Below\"),\n  \n  # Create the radio buttons\n  numericInput(inputId = \"my_input\",\n               label = \"Type a number\",\n               value = 25),\n  \n  # Add a line break\n  htmltools::hr(),\n  \n  # Close this tabPanel and start the next\n  ), tabPanel(title = \"Square Root\",\n  \n  # Also include a smaller header for the output\n  htmltools::h3(\"See Answer Below\"),\n  \n  # And print the output\n  \"Square root is: \",\n  textOutput(outputId = \"my_output\")\n  \n  # Close the current tab panel\n  )\n  \n  # Now close the `tabsetPanel(...` parentheses\n  )\n  \n  # Then close the whole `fluidPage` parentheses\n  )\n\n\n\nNote that the title argument defined in each tabPanel call becomes the words on the tab.\nOnce the layout has been defined in the UI, we can create another app using the tab layout but with the same server function as the other two apps.\n\n\n\n\n\n\n\n\n\n\n\nshinyApp(ui = tab_ui, server = layout_server)\n\n\n\nAn advantage of using tabPanels is that you can have essentially as many tabs as you desire. This allows for an app with a huge amount of data that users can still easily navigate."
  },
  {
    "objectID": "supp_mat.html",
    "href": "supp_mat.html",
    "title": "Supplementary Resources",
    "section": "",
    "text": "Much as we would love to cover everything to do with R Shiny, it is simply not possible given the time we have today. However, if this workshop inspired you to delve further into Shiny, we hope that the resources and readings below are helpful to you.\nThanks for coming to our workshop!\n– Gabe, Francisco, & Nick"
  },
  {
    "objectID": "supp_mat.html#further-reading",
    "href": "supp_mat.html#further-reading",
    "title": "Supplementary Resources",
    "section": "Further Reading",
    "text": "Further Reading\nThere are tons of incredibly helpful resources on Shiny floating around. Here’s a selection of our favorites.\n\nMastering Shiny by Hadley Wickham\nDeploying a Shiny App FAQ\nSam Csik’s Intro to Shiny workshop\nAllison Horst’s The Basics of Building Shiny Apps in R workshop\nGarrett Grolemund’s Building Web Applications with Shiny tutorial (GitHub repo here)\nDean Attali’s Building Shiny Apps, an Interactive Tutorial\nShiny User Showcase\nShiny Demos"
  },
  {
    "objectID": "supp_mat.html#deployed-shiny-apps",
    "href": "supp_mat.html#deployed-shiny-apps",
    "title": "Supplementary Resources",
    "section": "Deployed Shiny Apps",
    "text": "Deployed Shiny Apps\n\nData submission portal for the Herbivory Variability Network\nlterpalettefinder demo app\nWeatherSpark The Weather Year Round Anywhere on Earth: Climate reports with the weather by month, day, even hour. Great for event and trip planning!\nWisconsin’s Long-Term Water Quality Trends. How government agencies take advantage of the functionality of Shiny Apps to offer an interactive view of their long-term data sets."
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "Example Data",
    "section": "",
    "text": "The Long Term Ecological Research program (LTER) Network has recently created an R package containing example datasets from some of the LTER sites called lterdatasampler. The goal of lterdatasampler is to provide tidy versions of datasets from LTER sites for use in teaching and training contexts (like this workshop!). Eventually this package will contain datasets from each of the 28 extant LTER sites so be sure to check back often for updates as those data are integrated.\nFor this workshop, we’ll be using one of the datasets in this package to give our apps something to work with. Let’s explore that more fully below."
  },
  {
    "objectID": "data.html#andrews-forest-data",
    "href": "data.html#andrews-forest-data",
    "title": "Example Data",
    "section": "Andrews Forest Data",
    "text": "Andrews Forest Data\nSpecifically, we’ll be using the Andrews Forest (“AND”) LTER data. This dataset contains the length and width measurements of Cutthroat trout and salamanders found in Mack Creek at Andrews Forest.\nTo access this data, we’ll need to install the lterdatasampler dataset and we’ll also want both the tidyverse and librarian packages as well (for data wrangling and package installation convenience respectively).\n\n\n\n\n\n\n\n\n\n\n\n# install.packages(\"librarian\")\nlibrarian::shelf(lter/lterdatasampler, tidyverse)\n\n\n\nOnce we have the packages that we need, we can retrieve the data and take a look at it.\n\n\n\n\n\n\n\n\n\n\n\n# Load the data from AND\nand_data <- lterdatasampler::and_vertebrates\n\n# Take a quick look at it\ndplyr::glimpse(and_data)\n\nRows: 32,209\nColumns: 16\n$ year        <dbl> 1987, 1987, 1987, 1987, 1987, 1987, 1987, 1987, 1987, 1987…\n$ sitecode    <chr> \"MACKCC-L\", \"MACKCC-L\", \"MACKCC-L\", \"MACKCC-L\", \"MACKCC-L\"…\n$ section     <chr> \"CC\", \"CC\", \"CC\", \"CC\", \"CC\", \"CC\", \"CC\", \"CC\", \"CC\", \"CC\"…\n$ reach       <chr> \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\", \"L\"…\n$ pass        <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ unitnum     <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2…\n$ unittype    <chr> \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\", \"R\"…\n$ vert_index  <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1, …\n$ pitnumber   <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ species     <chr> \"Cutthroat trout\", \"Cutthroat trout\", \"Cutthroat trout\", \"…\n$ length_1_mm <dbl> 58, 61, 89, 58, 93, 86, 107, 131, 103, 117, 100, 127, 99, …\n$ length_2_mm <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ weight_g    <dbl> 1.75, 1.95, 5.60, 2.15, 6.90, 5.90, 10.50, 20.60, 9.55, 13…\n$ clip        <chr> \"NONE\", \"NONE\", \"NONE\", \"NONE\", \"NONE\", \"NONE\", \"NONE\", \"N…\n$ sampledate  <date> 1987-10-07, 1987-10-07, 1987-10-07, 1987-10-07, 1987-10-0…\n$ notes       <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n\n\n\n\n\nAND Data Dictionary\nInformation about the data in AND can be accessed by running ?and_vertebrates but for simplicity’s sake, the columns and their meanings are recapitulated here as well.\n\nyear – number – observation year\nsitecode – character – abbreviated name of sample area\nsection – character – section of Mack Creek CC = clear cut forest, OG = old growth forest upstream\nreach – character – reach sampled from each section; L = lower reach (0 - 50 meters), M = middle reach (50 - 100 meters), U = upper reach (100 - 150 meters))\npass – number – electroshocking pass number, either 1 or 2\nunitnum – number – channel unit number\nunittype – character – channel unit classification type (C = cascade, I = riffle, IP = isolated pool (not connected to channel), P = pool, R = rapid, S = step (small falls), SC = side channel, NA = not sampled by unit)\nvert_index – number – unique index for each vertebrate\npitnumber – number – unique tag number embedded into vertebrate (tagging started in 2007)\nspecies – character – species measured\nlength_1_mm – number – vertebrate length in millimeters; total or snout-fork length for trout, and snout-vent length for salamanders\nlength_2_mm – number – snout-tail length in millimeters (for Coastal giant salamander only)\nweight_g – number – vertebrate mass in grams\nclip – character – fin clip type for cutthroat trout, ended in 2006 (LV = left ventral fin; LVRV = left and right ventral fins; RV = right ventral fin; NONE = no ventral fin clip)\nsampledate – date – date of observation\nnotes – character – additional comments\n\nWe may not use all of these columns today but your app could rely on any of them that you so choose!"
  }
]